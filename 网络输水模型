互联网情况错综你复杂，数据包需要经过无数网络设备，延时无法避免。
由于TCP协议在网络层约定保证数据包的顺序切不会丢失。
所以，需要一个容器去存储数据。

查看网络通信可知，网络数据在传输过程中会出现缓存现象。
简单来说：就是连续发送N个数据包。【粘包】

对于接收端来说，也不能很好保证每次都接收到1个完整的数据包，很多时候是X,Y个数据包。

在回到输水模型，容器等待水的到来。

现在存在超时时间，即每次等待水到来有一个最大时间，
即：超过这个时间之后，及时没有得到一滴水，则处理这个水桶。
所以，得到水的理论值是大于等于0，小于水桶容量。

代码分析：
bytep[ buffer = new byte[MAX_LEN],
即数据包读取缓冲区。
read():使用buffer读数据流，
len:实际独处的数据长度，len <= MAX_LEN,len>=0(等于0不处理，等于-1视为连接断开)

buffer缓冲区，里面存储len长度可用数据。
需要做的就是根据协议结构，将buffer传话为遵循协议的数据包packet,交由后面的业务逻辑代码处理。

SO。定义逻辑层通信协议。
byteHeader:包头，用于验证数据包合法性验证。
2byte的数据包长【一般4byte,即一个int】
剩下内容为可变长度的数据包体



拿到buffer，存在分包，粘包和增速宝。
实际上，获得packet时我们仅仅需要知道数据包packet的真实长度。即2byte,转为short后假设为PACKET_LEN，
然后秩序拆分和等待 PACKET_LEN长度的byte即可。

ByteBuffer:底层还是 固定长度的byte[]，仅仅是封装了byte操作的快捷方式。









