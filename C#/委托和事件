委托和事件没有可比性，主要在于；
1）委托作为数据类型，事件是对象【理解为对委托变量的封装】

委托对象【委托方法实现的事件】和【标准的event方式实现】的事件的区别：

事件内部是委托实现

三种实现事件方式的区别：
1）直接使用委托实现
2）用私有委托+共有方法模拟事件
3）直接event事件



对于事件来说，外部只能“注册自己” ： +=
注销自己“”: -=
外部不可以注销其他的注册这，外界不可主动触发事件
如果使用Delegate就没有办法进行这样的控制
所以诞生了事件

事件是用来阉割委托实例的。事件只能add、remove自己，不能赋值。事件只能+=、-=，不能=、不能外部触发事件。 

1、委托的作用：

占位，在不知道将来要执行的方法的具体代码时，可以先用一个委托变量来代替方法调用（委托的返回值，参数列表要确定）。在实际调用之前，需要为委托赋值,否则为null。

2、事件的作用：

事件的作用与委托变量一样，只是功能上比委托变量有更多的限制。（比如：1.只能通过+=或-=来绑定方法（事件处理程序）2.只能在类内部调用（触发）事件。）

3、在自定义控件（自己编写控件的时候，会大量用到.编写控件的时候，会写一些事件。但是当这些事件 被触发以后，具体执行的那些事件处理程序是编写控件的人没法确定的。这个时候只能通过事件来占位（调用），具体调用的是哪个方法，由使用控件的人来决定（Click+=new 委托(方法名);））

先有观察者模式，再有委托事件这一技术。它有一个前后顺序，如果你要彻底学会委托事件，那么就要先学会观察者模式，还要了解观察者模式的缺陷。

观察者模式的缺陷：

观察者模式是对主题对象和观察者对象进行解耦，使双方都依赖与抽象，而不是依赖于对方的具体对象，
、使双方的变化都不会影响到对方的具体对象。当多个对象需要根据一个对象的状态发生相应的改变或操作时，
可使用观察者模式。



猫和人抓老鼠：
1）老鼠是主体对象
2）猫和人是观察者

https://blog.csdn.net/q493201681/article/details/82352616






