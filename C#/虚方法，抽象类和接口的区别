虚方法和普通方法其实差不多。

虚方法（virtual）可以实例化调用，也可以被继承类重写（Override）

它的作用是当实例类型从继承类转换为基类时，类中方法仍然是继承类中的实现。


如果不使用虚方法而使用普通方法隐藏基类方法，那么当实例类型转换时，编程了基类的实现。

抽象类（抽象方法）和接口类似，继承类都需要实现它们声明的函数。 
抽象方法声明使用，是必须被派生类覆写的方法，抽象类就是用来被继承的；可以看成是没有实现体的虚方法；如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法；抽象类不能有实体的。

相同点： 
(1) 都可以被继承 
(2) 都不能被实例化 
(3) 都可以包含方法声明 
(4) 派生类必须实现未实现的方法

不同点： 
(1) 抽象基类可以定义字段、属性、方法实现；接口只能定义属性、索引器、事件、和方法声明，不包含字段以及方法实现。 
(2) 抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。 
(3) 接口可以被多重实现，抽象类只能被单一继承 
(4) 抽象类的成员可以具有访问级别,而接口的成员全部public级别 
(5) 抽象的子类可以选择性实现其基类的抽象方法,而接口的子类必须实现 
(6) 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法 
(7) 接口可以用于支持回调,而继承并不具备这个特点 
(8) 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的 
(9) 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法
