透明效果主要有两种实现方式：
1）透明度测试【无法实现真正的半透明效果】
2）透明度混合

透明度测试和透明度混合：


透明度测试：1）只有一个片元的透明度不满足条件（通常是小于某个阙值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，
也不会对颜色缓冲产生任何影响。否则会被当做不透明处理，进行深度测试，深度写入等。所以透明度测试是不需要关掉深度写入的。
除了会舍弃片元，其实和不透明物体渲染差不多。

透明度混合：
这种方法可以得到真正的半透效果。它会使用当前片元的透明度作为混合因子，与颜色缓冲中的颜色进行混合，得到新的颜色。这里需要注意，
透明度混合需要关闭深度写入。但没有关闭深度测试，所以当混合渲染一个片元时，它还是会比较它的深度和深度缓冲中的深度，
如果它的深度值离摄像机更远，则不再进行混合操作。所以当不透明物体在透明物体前面时，先渲染了不透明物体，它仍可以遮挡主透明物体。
所以对于透明度混合来说，深度缓冲只是可读的。

Shader 渲染顺序的问题：

一般渲染引擎内部会有机制：
1）先渲染所有不透明物体，并且开启深度测试和写入
2）把半透明的物体按照离摄像机远近顺序，按照从后往前顺序渲染，开启深度测试，关闭深度写入。


渲染队列，SubShader的Queue标签决定渲染顺序。

Background:
Geometry:
AlphaTest:
Transparent:
Overlay:


//透明度测试
SubShader
{
  Tags{"Queue" = "AlphaTest"}
  Pass{}
  
}

//透明度混合
  SubShader
  {
    Tags{"Queue" = "Transparent"}
    Pass
    {
      ZWrite Off
    }
  }




