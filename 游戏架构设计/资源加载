通常推荐使用AssetBundle来加载资源，使用AssetBundle可以按更小的包来管理资源、更新资源，同时还可以加快游戏启动速度。
但是，
加载AssetBundle需要我们自己去维护依赖关系，对比起Resources来说更加麻烦。通常在开发的时候使用Resources加载，
而在发布版本使用AssetBundle。这里需要实现自己的加载器来满足两套资源的切换。

资源管理器：
1）统一的Resources和AssetBundles加载
2)类似的加载接口设计，包括同步与异步
3)强引用计数管理，Load与Unload匹配
4)支持按优先级加载资源
5)支持配置系统开销，异步加载开销


类似的加载接口设计，包括同步与异步
强引用计数管理，Load与Unload匹配
支持按优先级加载资源
支持配置系统开销，异步加载开销

外实现为静态接口，正常情况下支持Editor运行时与非运行时，运行时不管在PC还是手机都支持Resources与AssetBundles无缝切换。
所有的加载路径参数统一为Resources目录相对路径且不包含扩展名，这里要求在同一目录不要有同名文件（仅扩展名不一样）。
按类型匹配资源是较烦琐的工作，而且对于Object基类加载，无法匹配到正确的资源。
异步接口定义一个自己Request类返回，除了原有的ResourceRequest数据，这里新增一个打断属性。
当不再持有这个对象的时候设置打断属性来中断加载。同时这里还支持配置回调接口，这样不需要每次更新去查询状态，资源管理器在异步加载完成后执行回调接口。
异步加载接口增加优先级参数，优先加载高优先级的对象。自己维护一个优先级列表，并发起一定数量的异步加载请求，
对于在队列中被打断的资源则可以节省一次资源价值请求。


然后还要关注异步加载的开销，避免异步加载占用太多的主线程时间。

由于实现了自己Request，所以这里也要实现自己的时间片管理器。实例化对象与回调接口的开销都是不可预期的，
我们配置一个每帧最大执行时间做平滑。
最后讨论下资源卸载策略，实时卸载资源导致资源反复加载，引起游戏卡顿。
通常会缓存一定数量的资源来改善体验，由于只有调用了UnloadUnusedAsset才会真正清理资源，所以一般情况下会一直持有资源，
然后根据未使用的资源数量情况触发统一的UnloadUnusedAsset，这时候资源才会被真正释放。由于我们使用了强引用计数管理，
所以在清理的时候通过对引用计数的判断就可以正确的清理资源。特别对于使用AssetBundle加载资源的情况，错误的管理可能会导致资源重复加载，浪费内存。

资源对象池
资源加载器负责加载、卸载资源，同时缓存资源，这里的资源对象池特指GameObject资源池。GameObject资源通常带有自己的数据，在加载的时候需要实例化一份以便使用。实例化GameObject是一个开销较大的操作，同时也会带来较高的GC Alloc（内存分配）。资源对象池就是一个GameObject对象池用于缓存实例化的GameObject对象。
资源对象池在使用上要注意GameObject对象的可复用性，开始的时候加载一个预制体（Prefab）是一个干净的数据。
外部逻辑会修改GameObject上的数据、添加新的组件，之后这个对象会入池。设计上如果一个对象需要使用对象池的复用功能，
逻辑需要保证这个GameObject是可复用的，这并不是一件容易的事情。把状态还原重置本身就有一定的开销，如果实例化一个对象的成本低于重置数据的
开销，那就不需要对象池，每次重新实例化即可。


同时在对象入池的时候还需要做一项工作是让对象不可见，与销毁一个对象（对象入池）在这里保持行为一致。有两个常见的做法，一个是SetActive(false)，
还有一个做法是把对象移出摄像机。对于对象数特别多的对象修改坐标的开销较大，对于组件较多的对象修改激活状态的开销可能会更大。这里提供了三种入池行为，InActive、InVisible、Destroy用于处理上面讨论的情况。





资源对象池封装实现自己的一个Spawn接口，表示生成一个对象，然后对应的一个Despawn接口用于销毁对象。
这里还提供了异步的SpawnAsync接口用于异步加载以及错帧实例化，使游戏体验更加平滑。对于Spawn接口提供带初始坐标的实例化接口与Instantiate保持一致，
提供初始坐标减少坐标次数，一般来说可以得到5%-10%的性能提升。对于一些拖尾特效，正确的坐标也可以避免特效拉一条从原点到当前位置的长线。
最后讨论下资源池的缓存策略，通常资源池里面存在两种情况的资源。一种外部还存在相同的对象在使用，另一种则是所有的对象都在资源池。
对于所有对象都在资源池的对象，可以认为是不使用资源根据时间淘汰。对于外部存在引用的情况，增加其权重值但还是会按时间来淘汰。存在部分类型资源会有较多
的实例而部分资源只有一两个实例，这里做资源池总上限的约束而不做单类型数量约束。在激烈的战斗场景下对象数量会远远高于平时，过小的资源池上限会导致卡顿
，过大的资源池上限会导致内存过高。这里增加一个资源池下限，当资源池对象数高于这个数目的时候执行按时间清理操作，然后配置一个较高的资源池上限
而不用当心资源池一直占用过高的内存，得到一个性能与内存兼顾的结果。





